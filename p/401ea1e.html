<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>搜索算法 | 番茄元🍅の小窝</title><meta name="author" content="tomatoyuan"><meta name="copyright" content="tomatoyuan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="搜索算法  被可爱的女孩子问懵了，学艺不精，翻车的我决定重新理解一下这几个算法 wiki真是个好东西，它真的我哭死  1. 深度优先搜索（Depth-First-Search, DFS）  不多说，遍历顺序如下图序号    2. 广度优先搜索（Breadth-first search, BFS）  也不多说，遍历顺序在图中    3. 启发式搜索策略 3.1 爬山法（Hill climbing）">
<meta property="og:type" content="article">
<meta property="og:title" content="搜索算法">
<meta property="og:url" content="https://tomatoyuan.github.io/p/401ea1e.html">
<meta property="og:site_name" content="番茄元🍅の小窝">
<meta property="og:description" content="搜索算法  被可爱的女孩子问懵了，学艺不精，翻车的我决定重新理解一下这几个算法 wiki真是个好东西，它真的我哭死  1. 深度优先搜索（Depth-First-Search, DFS）  不多说，遍历顺序如下图序号    2. 广度优先搜索（Breadth-first search, BFS）  也不多说，遍历顺序在图中    3. 启发式搜索策略 3.1 爬山法（Hill climbing）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tomatoyuan.github.io/img/bg99.jpg">
<meta property="article:published_time" content="2022-11-17T16:17:20.000Z">
<meta property="article:modified_time" content="2022-11-21T03:41:25.123Z">
<meta property="article:author" content="tomatoyuan">
<meta property="article:tag" content="算法-搜索">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tomatoyuan.github.io/img/bg99.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://tomatoyuan.github.io/p/401ea1e"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: tomatoyuan","link":"链接: ","source":"来源: 番茄元🍅の小窝","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '搜索算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-21 11:41:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/mylogo.bmp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/bg99.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">番茄元🍅の小窝</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">搜索算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-17T16:17:20.000Z" title="发表于 2022-11-18 00:17:20">2022-11-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-21T03:41:25.123Z" title="更新于 2022-11-21 11:41:25">2022-11-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>14分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="搜索算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>搜索算法</h1>
<blockquote>
<p>被可爱的女孩子问懵了，学艺不精，翻车的我决定重新理解一下这几个算法</p>
<p><font color="purple">wiki真是个好东西，它真的我哭死</font></p>
</blockquote>
<h2 id="1-深度优先搜索-depth-first-search-dfs">1. 深度优先搜索（Depth-First-Search, DFS）</h2>
<blockquote>
<p>不多说，遍历顺序如下图序号</p>
</blockquote>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/401ea1e/300px-Depth-first-tree.svg.png" class title="节点搜索的顺序">
<h2 id="2-广度优先搜索-breadth-first-search-bfs">2. 广度优先搜索（Breadth-first search, BFS）</h2>
<blockquote>
<p>也不多说，遍历顺序在图中</p>
</blockquote>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/401ea1e/300px-Breadth-first-tree.svg.png" class title="Order in which the nodes get expanded">
<h2 id="3-启发式搜索策略">3. 启发式搜索策略</h2>
<h3 id="3-1-爬山法-hill-climbing">3.1 爬山法（Hill climbing）</h3>
<p>爬山法是完完全全的贪心法，每次都鼠目寸光的选择一个当前最优解，因此只能搜索到局部的最优值。</p>
<p><strong>例题：</strong> 以八数码为例</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/401ea1e/image-20221118112147486.png" class title="image-20221118112147486">
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/401ea1e/image-20221118112208202.png" class title="image-20221118112208202">
<p>每一步都选择局部最优，最后很可能陷入一个局部最优解。</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/401ea1e/image-20221118112307985.png" class title="image-20221118112307985">
<p>那么能不能优化一下呢？当它找到某个山顶时，可以给个随机数，随机一下，就有概率找到更优的解（同时也承担着找到更差解的风险）。下面以模拟退火为例，</p>
<p>模拟退火其实也是一种贪心算法，但是它的搜索过程引入了随机因素.。模拟退火算法以一定的概率来接受一个比当前解要差的解，因此有可能会跳出这个局部的最优解，达到全局的最优解。以上图为例，模拟退火算法在搜索到局部最优解A后，会以一定的概率接受到E的移动。也许经过几次这样的不是局部最优的移动后会到达D点，于是就跳出了局部最大值A。</p>
<h3 id="3-2-最佳优先搜索-best-first-search">3.2 最佳优先搜索（Best-first search）</h3>
<p>首先看一下wikipedia对 <code>Best-first search</code> 算法的解释</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/401ea1e/image-20221118003835733.png" class title="image-20221118003835733">
<p>说法不是很统一，大概是两种</p>
<ol>
<li>
<p>可以是 <code>A*</code> 这样的启发式函数，既用到了从起点到当前点的评价，也用到了从当前点到目标点的估价。</p>
</li>
<li>
<p>可以是 <code>greedy best-first search</code> 基于贪心策略的优先搜索，即只用到从当前点到达目标点的估价。</p>
</li>
</ol>
<p>这里我选择第二种来理解，<code>wiki</code> 给出的伪代码如下，看算法名字就很形象，贪心的 <code>BFS</code></p>
<h2 id="greedy-bfs">Greedy BFS</h2>
<p>Using a greedy algorithm, expand the first successor of the parent. After a successor is generated:</p>
<p>使用贪心算法，将队列中的所有结点排序后，将队列中位于队首的结点出队，将其所有子节点拓展进队列</p>
<ol>
<li>
<p>If the successor’s heuristic is better than its parent, the successor is set at the front of the queue (with the parent reinserted directly behind it), and the loop restarts.</p>
<p>如果后代节点的估价更优，则可以放在父节点的前面。（实现过程可以是用普通队列让所有节点出队，重新排序后入队；也可以使用优先队列（堆），这样每次优先队列的队首（堆顶）都是当前队列中估价最优的节点）</p>
</li>
<li>
<p>Else, the successor is inserted into the queue (in a location determined by its heuristic value). The procedure will evaluate the remaining successors (if any) of the parent.</p>
<p>如果新加入的节点估价不好，按照估价排序放在队列中的对应位置就行</p>
</li>
</ol>
<p>Below is a pseudocode example of this algorithm, where <strong>queue</strong> represents a priority queue which orders nodes based on their heuristic distances from the goal. This implementation keeps track of visited nodes, and can therefore be used for undirected graphs. It can be modified to retrieve the path.</p>
<p>下面是该算法的伪代码示例，其中 queue 表示优先级队列，它根据节点与目标的启发式距离对节点进行排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">procedure GBS(start, target) <span class="keyword">is</span>:</span><br><span class="line">  mark start <span class="keyword">as</span> visited</span><br><span class="line">  add start to queue</span><br><span class="line">  <span class="keyword">while</span> queue <span class="keyword">is</span> <span class="keyword">not</span> empty do:</span><br><span class="line">    current_node ← vertex of queue <span class="keyword">with</span> <span class="built_in">min</span> distance to target</span><br><span class="line">    remove current_node <span class="keyword">from</span> queue</span><br><span class="line">    foreach neighbor n of current_node do:</span><br><span class="line">      <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> visited then:</span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">is</span> target:</span><br><span class="line">          <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          mark n <span class="keyword">as</span> visited</span><br><span class="line">          add n to queue</span><br><span class="line">  <span class="keyword">return</span> failure </span><br></pre></td></tr></table></figure>
<p>可以看到，每个节点都会被 <code>visited</code> 标记，即每个节点只能访问一次，每次都是<strong>贪心</strong>的选择下一步的最优解，不回头更新之前的搜索过的结果，可能会陷入局部最优。</p>
<p><strong>例题：</strong> 以八数码为例，使用优先队列（小顶堆）</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/401ea1e/image-20221118110530036.png" class title="image-20221118110530036">
<p>贪心的选择队列中的元素做搜索</p>
<ul>
<li>开始根节点入队，与目标情况差距为3，即1，2，8不在正确的位置上</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3(一层一号)]</span><br></pre></td></tr></table></figure>
<ul>
<li>根节点出队，将其子节点放入优先队列</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3(二层一号), 3(二层二号), 4(二层三号), 4(二层四号)]</span><br></pre></td></tr></table></figure>
<ul>
<li>取出 <code>3(二层一号)</code> ，将其子节点放入优先队列</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3(二层二号), 3(三层层二号), 4(二层三号), 4(二层四号), 4(三层一号)]</span><br></pre></td></tr></table></figure>
<ul>
<li>取出 <code>3(二层二号)</code> ，将其子节点放入优先队列</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2(三层三号), 3(三层层二号), 4(二层三号), 4(二层四号), 4(三层一号), 4(三层四号)]</span><br></pre></td></tr></table></figure>
<ul>
<li>取出 <code>2(三层三号)</code>, 将其子节点放入优先队列</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1(四层一号), 3(三层层二号), 4(二层三号), 4(二层四号), 4(三层一号), 4(三层四号)]</span><br></pre></td></tr></table></figure>
<ul>
<li>取出 <code>1(四层一号)</code>, 在其子节点中找到目标节点， <code>0(五层一号)</code>，找到可行解，搜索停止</li>
</ul>
<p>可以看到 <code>Best-first search</code> 并没有剪枝操作，只是贪心的选择搜索的下一个节点，找到的可能是局部最优解。</p>
<h2 id="4-代价一致搜索-dijkstra">4. 代价一致搜索（Dijkstra）</h2>
<p>代价一致搜索其实就是 <code>Dijkstra</code> 其搜索过程如下图所示</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/401ea1e/220px-Dijkstra_Animation.gif" class title="Dijkstra Animation.gif">
<p>与 <code>Best-first search</code> 不一样的地方:</p>
<ul>
<li>这里寻找点，用到的是从<strong>起点</strong>到<strong>当前点</strong>的距离</li>
<li>这里<strong>不</strong>限制每个节点的访问次数，找到一个更优的解，就可以去更新所有已经搜索过的路径长度，最后获得全局最优解。</li>
</ul>
<p><strong>伪代码（Pseudocode）如下</strong></p>
<p><code>dist[u]</code> 是从源点到顶点 u 的当前距离。</p>
<p><code>Graph.Edges(u, v)</code> 返回连接两个邻居节点 u 和 v 的边的长度（即之间的距离）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>  function Dijkstra(Graph, source):</span><br><span class="line"> <span class="number">2</span>      </span><br><span class="line"> <span class="number">3</span>      <span class="keyword">for</span> each vertex v <span class="keyword">in</span> Graph.Vertices:</span><br><span class="line"> <span class="number">4</span>          dist[v] ← INFINITY</span><br><span class="line"> <span class="number">5</span>          prev[v] ← UNDEFINED</span><br><span class="line"> <span class="number">6</span>          add v to Q</span><br><span class="line"> <span class="number">7</span>      dist[source] ← <span class="number">0</span></span><br><span class="line"> <span class="number">8</span>      </span><br><span class="line"> <span class="number">9</span>      <span class="keyword">while</span> Q <span class="keyword">is</span> <span class="keyword">not</span> empty:</span><br><span class="line"><span class="number">10</span>          u ← vertex <span class="keyword">in</span> Q <span class="keyword">with</span> <span class="built_in">min</span> dist[u]</span><br><span class="line"><span class="number">11</span>          remove u <span class="keyword">from</span> Q</span><br><span class="line"><span class="number">12</span>          </span><br><span class="line"><span class="number">13</span>          <span class="keyword">for</span> each neighbor v of u still <span class="keyword">in</span> Q:</span><br><span class="line"><span class="number">14</span>              alt ← dist[u] + Graph.Edges(u, v)</span><br><span class="line"><span class="number">15</span>              <span class="keyword">if</span> alt &lt; dist[v]:</span><br><span class="line"><span class="number">16</span>                  dist[v] ← alt</span><br><span class="line"><span class="number">17</span>                  prev[v] ← u</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span>      <span class="keyword">return</span> dist[], prev[]</span><br></pre></td></tr></table></figure>
<p>可以看到，一个节点可以多次入队，可以反复更新之前搜索过的路径，最后获得全局最优解。</p>
<h2 id="5-分支限界-branch-and-bound-简称bb">5. 分支限界（Branch and bound，简称BB）</h2>
<blockquote>
<p>分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。在分支限界法中，每一个活结点（没被访问过的节点）只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所需的解或活结点表为空时为止。</p>
</blockquote>
<p>首先对比一下<strong>回溯法</strong>和<strong>分支限界法</strong></p>
<ul>
<li>
<p>回溯法：一种基于深度优先搜索的剪枝策略</p>
<ul>
<li>
<p>回溯法的求解目标是找出解空间树中满足约束条件的<strong>所有解</strong></p>
</li>
<li>
<p>利用深度优先搜索的方法，当搜到一个显然不合理的结果时，没必要继续深入搜索，这时利用回溯回退到其父节点，寻找下一个值得继续搜索的节点。如此可以剪去一些不必要的搜索，同时可以找到所有可能的结果。</p>
</li>
</ul>
</li>
<li>
<p>分支限界法：常基于广度优先搜索的剪枝策略</p>
<ul>
<li>分支限界法的求解目标是找出满足约束条件的<strong>一个解</strong>，或是在满足约束条件的解中找出在某种意义下的最优解。</li>
<li>利用广度优先搜索，首先根据已知的条件确定到达目标节点的代价上界，并估计当前可达拓展节点的代价下界，如果可拓展节点的代价下界超出到达目标节点的代价上界时，该节点肯定不是最优解了，抛弃之，即剪枝。</li>
<li>实现方法可以有很多，原理差不多，一般选用优先队列，比较简单好理解
<ul>
<li>队列式(FIFO)分支限界法：按照队列先进先出（FIFO）原则选取下一个节点为扩展节点。</li>
<li>LC（最小代价）分支限界法：采用优先队列作为活结点表</li>
<li>栈式(LIFO)分支限界法：按照栈的存储方式排序拓展节点</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>例题</strong>：以单源最短路为例来解释分支界限法的计算过程：求从S-&gt;T的最短距离（括号内为从起点到达当前点的路径长度）</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/401ea1e/image-20221118110316892.png" class title="image-20221118110316892">
<ul>
<li>首先根节点（出发点）进入优先队列</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[S(0)]</span><br></pre></td></tr></table></figure>
<ul>
<li>根节点出队，拓展根节点，将其可达的三个子节点入队</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/401ea1e/image-20221118102323569.png" class title="image-20221118102323569">
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[A(2), B(3), C(4)]:此时S-&gt;A的代价最小，所以优先队列队首（堆顶）是A节点</span><br></pre></td></tr></table></figure>
<ul>
<li>队首A节点出队，拓展A节点，其子节点入队</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/401ea1e/image-20221118104112193.png" class title="image-20221118104112193">
<p>由于每个节点只能拓展一次，当出现两个<strong>相同</strong>可拓展节点时，即将出现<strong>重复</strong>的搜索，此时进行对重复搜索的剪枝，选择代价最优的拓展，这里舍弃路径较长的 <code>B(5)</code> ，即更新 <code>B</code> 节点的代价下界为 3。（当出现代价小于 3 的 <code>B</code> 节点，则更新 <code>B</code> 节点的最小下界，并替换 <code>B</code> 节点，否则丢弃新找到的节点）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[B(3), C(4), D(9), E(4)]</span><br></pre></td></tr></table></figure>
<ul>
<li>取出此时代价最小的节点 <code>B</code> 做拓展</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/401ea1e/image-20221118104021306.png" class title="image-20221118104021306">
<p><code>E</code> 节点的下界此时为 4 ，剪枝舍弃新的节点 <code>E(12)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[C(4), D(9), E(4), F(5)]</span><br></pre></td></tr></table></figure>
<ul>
<li>取出此时代价最小的节点 <code>C</code> 做拓展</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/401ea1e/image-20221118104437183.png" class title="image-20221118104437183">
<p><code>F</code> 节点的下界此时为 5 ，剪枝舍弃新的节点 <code>F(6)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[D(9), E(4), F(5)]</span><br></pre></td></tr></table></figure>
<ul>
<li>取出此时代价最小的节点 <code>E</code> 做拓展</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/401ea1e/image-20221118104737397.png" class title="image-20221118104737397">
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[D(9), F(5), H(7)]</span><br></pre></td></tr></table></figure>
<ul>
<li>取出此时代价最小的节点 <code>F</code> 做拓展</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/401ea1e/image-20221118105013303.png" class title="image-20221118105013303">
<p>更新 <code>H</code> 下界为 6，舍弃原来的 <code>H(7)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[D(9), H(6), I(6)]</span><br></pre></td></tr></table></figure>
<ul>
<li>取出此时代价最小的节点 <code>H</code> 做拓展</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/401ea1e/image-20221118105456775.png" class title="image-20221118105456775">
<p>这里贪心的找到了第一个可行解，记录从起点到达终点的代价上界为 8 。（此时如果再出现下界小于上界的节点，则直接抛弃，这部分是舍弃不必要搜索的剪枝）</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/401ea1e/image-20221118105824512.png" class title="image-20221118105824512">
<p>这里把 <code>D(9)</code> 分支剪掉，因为 <code>D</code> 此时的代价下界已是 9，超过起点到达目标点的上界，不可能找到更优的解，直接舍弃该分支。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[I(6)]</span><br></pre></td></tr></table></figure>
<ul>
<li>取出此时代价最小的节点 <code>I</code> 做拓展</li>
</ul>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/401ea1e/image-20221118110243588.png" class title="image-20221118110243588">
<p>找到一个更优的可行解，更新起点到终点的上界为 7</p>
<p>此时优先队列为空，搜索结束，最短路径长为 7</p>
<h2 id="6-动态规划-dynamic-programming">6. 动态规划（Dynamic programming）</h2>
<p>动态规划在查找有很多<strong>重叠子问题</strong>的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间。</p>
<p>动态规划只能应用于有<strong>最优子结构</strong>的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。</p>
<p><strong>例题1（无向图）：</strong> 以下图为例，求解 <code>S-&gt;T</code> 的最短路径</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/401ea1e/image-20221118112709161.png" class title="image-20221118112709161">
<p>首先考虑如何拆解问题，</p>
<p>从一个点到达另一个点只有两种方式：</p>
<ul>
<li>直接到达</li>
<li>通过其他点中转到达</li>
</ul>
<p>想知道 <code>S-&gt;T</code> 的最短距离，对于他们路径上某个点 <code>x</code> ，只需要知道 <code>S-&gt;X</code> 的最小距离和 <code>X-&gt;T</code> 的最小距离，即可推出经过点 <code>X</code> 的情况下，<code>S-&gt;T</code> 的最短距离。</p>
<p>邻接矩阵：<code>dp[i][j]</code> 表示 <code>i-&gt;j</code> 的路径距离</p>
<p>状态转移方程如下：取当前的最短路径和经过 <code>X</code> 中转之后的最短路径中的最小值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[S][T] = min(dp[S][T], dp[S][X] + dp[X][T]);</span><br></pre></td></tr></table></figure>
<p>根据上图可以的到的邻接矩阵如下</p>
<ul>
<li>0 表示 节点到自己距离为 0</li>
<li>空表示 <code>dist[i][j] = inf</code> 即 <code>i, j</code> 两点之间不可达，距离为无穷大</li>
<li>其余数字代表 <code>dist[i][j]</code> 即 <code>i-&gt;j</code> 的边长距离</li>
</ul>
<table>
<thead>
<tr>
<th>i\j</th>
<th>S</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>t</th>
</tr>
</thead>
<tbody>
<tr>
<td>S</td>
<td>0</td>
<td>3</td>
<td></td>
<td></td>
<td>4</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>A</td>
<td>3</td>
<td>0</td>
<td>4</td>
<td></td>
<td>5</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>B</td>
<td></td>
<td>4</td>
<td>0</td>
<td>4</td>
<td></td>
<td>5</td>
<td></td>
<td></td>
</tr>
<tr>
<td>C</td>
<td></td>
<td></td>
<td>4</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>D</td>
<td>4</td>
<td>5</td>
<td></td>
<td></td>
<td>0</td>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>E</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>2</td>
<td>0</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>F</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>4</td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td>t</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>3</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>动态规划过程如下：</p>
<p>首先初始化所有的 <code>dp[i][j]</code> 为当前邻接矩阵中的值</p>
<p>从目标结论出发，逐步递推，就可将问题转化到我们已知的初始值上，即 <code>dp[S][A]</code> 和 <code>dp[S][D]</code></p>
<p><code>S-&gt;t</code> : <code>dp[S][t] = min(dp[S][t], dp[S][K] + dp[K][t]);</code> K 可能是剩余节点中任何一个可能到达 <code>t</code> 的节点</p>
<p><code>S-&gt;F</code> : <code>dp[S][F] = min(dp[S][F], dp[S][K] + dp[K][F]);</code> K 可能是剩余节点中任何一个可能到达 <code>F</code> 的节点</p>
<p><code>S-&gt;E</code> : <code>dp[S][E] = min(dp[S][E], dp[S][K] + dp[K][E]);</code> K 可能是剩余节点中任何一个可能到达 <code>E</code> 的节点</p>
<p>…</p>
<p><code>S-&gt;A</code> : <code>dp[S][A] = min(dp[S][A], dp[S][K] + dp[K][A]);</code> K 只能是 S ， 此时得到 <code>dp[S][A] = 3;</code></p>
<p><code>S-&gt;D</code> : <code>dp[S][D] = min(dp[S][D], dp[S][K] + dp[K][D]);</code> K 只能是 S ， 此时得到 <code>dp[S][D] = 4;</code></p>
<p>那么我们从下向上递推，就能通过逐步更新到达前面节点的最小距离，得到我们要的答案 <code>dp[S][T]</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; n; t++) &#123; <span class="comment">// 按邻接表中的顺序给搜索树编号</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; t; k++) &#123;</span><br><span class="line">		dp[<span class="number">0</span>][t] = min(dp[<span class="number">0</span>][t], dp[<span class="number">0</span>][k] + dp[k][t]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递推的过程可以看作从前往后建立一颗搜索树（不能抵达待更新路径终点的节点没有画出），下图的 <code>g = dp[0][i]</code></p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/401ea1e/image-20221118135533558.png" class title="image-20221118135533558">
<p>有多条路径能够到达某个节点时，在动态规划的过程中，已经将最短路径做了更新，之后每次用到的都是当前已知路径中最短的路径，相当对那些较长的路径做了剪枝，保留最短路径而删去之前找到的较长路径，不从这些路径继续向下寻找。</p>
<p><strong>例题2（有向图，）：</strong> 一张来自阿里云社区的博客动图</p>
<blockquote>
<p>如果拓展表中有多条到达某一公共节点的路径时，只保留耗散值最小的路径，其余删去。</p>
<p>下图橙色箭头就是在拓展节点，当拓展到的节点已经有可达路径时，判断新的路径和之前的路径哪个耗散值最小（即路径长度最小），保留最小长度的路径，其余路径删去，之后的拓展，基于这个最短的路径值继续拓展。</p>
</blockquote>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/401ea1e/9b98a61b5f9041f3a7aafbb26a635841.gif" class title="img">
<p>邻接矩阵：<code>dist[i][j]</code> 表示 <code>i-&gt;j</code> 的路径距离</p>
<p><code>dp[i]</code> 表示从起点到达节点 <code>i</code> 的最小距离</p>
<p>状态转移方程如下：取当前的最短路径和经过 <code>X</code> 中转之后的最短路径中的最小值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[T] = min(dp[T], dp[X] + dist[X][T]);</span><br></pre></td></tr></table></figure>
<p>动态规划核心代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; n; j++) &#123; <span class="comment">// 首先以第一个点作为终点，从前往后递推，不断把终点后移直到终点，其之前的节点的路径已经都算出来了，可作为动态规划的条件</span></span><br><span class="line">    <span class="keyword">for</span> (i = j - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dist[i][j] + dp[i] &lt; dp[j]) &#123;</span><br><span class="line">            dp[j] = dist[i][j] + dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br></pre></td></tr></table></figure>
<h2 id="参考文章">参考文章</h2>
<p>Depth-First-Search: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Depth-first_search">https://en.wikipedia.org/wiki/Depth-first_search</a></p>
<p>Breadth-first search: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Breadth-first_search">https://en.wikipedia.org/wiki/Breadth-first_search</a></p>
<p>Hill climbing: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hill_climbing">https://en.wikipedia.org/wiki/Hill_climbing</a></p>
<p>Best-first search: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Best-first_search">https://en.wikipedia.org/wiki/Best-first_search</a></p>
<p>Dijkstra’s algorithm: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">https://en.wikipedia.org/wiki/Dijkstra’s_algorithm</a></p>
<p>Branch and bound: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Branch_and_bound">https://en.wikipedia.org/wiki/Branch_and_bound</a></p>
<p>Dynamic programming: <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">https://zh.wikipedia.org/wiki/动态规划</a></p>
<p>七七八八百科：<a target="_blank" rel="noopener" href="https://www.cxyzjd.com/article/weixin_42715356/83089108">https://www.cxyzjd.com/article/weixin_42715356/83089108</a></p>
<p>快懂百科：<a target="_blank" rel="noopener" href="https://www.baike.com/wikiid/6434614434763778717?prd=mobile&amp;view_id=28w07z5dmyas00">https://www.baike.com/wikiid/6434614434763778717?prd=mobile&amp;view_id=28w07z5dmyas00</a></p>
<p>阿里云社区：<a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/1047074">https://developer.aliyun.com/article/1047074</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://tomatoyuan.github.io">tomatoyuan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://tomatoyuan.github.io/p/401ea1e.html">https://tomatoyuan.github.io/p/401ea1e.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://tomatoyuan.github.io" target="_blank">番茄元🍅の小窝</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2/">算法-搜索</a></div><div class="post_share"><div class="social-share" data-image="/img/bg99.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/96eafb50.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/bg71.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">人工智能（三）</div></div></a></div><div class="next-post pull-right"><a href="/p/cb9860d2.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/bg37.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Brute Force</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/mylogo.bmp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">tomatoyuan</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/tomatoyuan"><i class="fab fa-github"></i><span>🛴带你去我家...</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/tomatoyuan" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:Awellfrog@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><center>主域名：<br><a href="https://tomatoyuan.github.io"><b><font color="#5ea6e5">tomatoyuan.github.io</font></b></a></center></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">搜索算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-depth-first-search-dfs"><span class="toc-text">1. 深度优先搜索（Depth-First-Search, DFS）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-breadth-first-search-bfs"><span class="toc-text">2. 广度优先搜索（Breadth-first search, BFS）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5"><span class="toc-text">3. 启发式搜索策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%88%AC%E5%B1%B1%E6%B3%95-hill-climbing"><span class="toc-text">3.1 爬山法（Hill climbing）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%9C%80%E4%BD%B3%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-best-first-search"><span class="toc-text">3.2 最佳优先搜索（Best-first search）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#greedy-bfs"><span class="toc-text">Greedy BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BB%A3%E4%BB%B7%E4%B8%80%E8%87%B4%E6%90%9C%E7%B4%A2-dijkstra"><span class="toc-text">4. 代价一致搜索（Dijkstra）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C-branch-and-bound-%E7%AE%80%E7%A7%B0bb"><span class="toc-text">5. 分支限界（Branch and bound，简称BB）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dynamic-programming"><span class="toc-text">6. 动态规划（Dynamic programming）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-text">参考文章</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By tomatoyuan</div><div class="footer_custom_text">I am a frog at the bottom of a well, but I never give up climbing up.</br>我多努力一点，我爱的人就可以多休息一会儿😊<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ ">&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a>&nbsp;<a target="_blank" href="https://icp.gov.moe/?keyword=20230070"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/%E8%90%8CICP%E5%A4%87-20230070-fe1384?style-flat&logo=data:image/png" title="萌ICP备20230070号"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-api-beta-two.vercel.app/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-api-beta-two.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="/js/light.js"></script><script defer src="/js/cursor.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'c189a6faa11e45499d5f54f4af4961b9';
  var gaud_map_key = 'f373eae7d7ddbee8cd012fdc2720f4e5';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>